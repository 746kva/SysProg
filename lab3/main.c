#include <stdio.h>
#include <stdlib.h>

void min_max(char *array, char *max, char *max_p)
{
    __asm__
    (
        "movl $9, %%ecx\n\t"            // счетчик циклов (размер массива)
        "movq %0, %%r8\n\t"             // адрес массива (нулевой элемент)
        "movb (%%r8), %%bl\n\t"         // нулевой элемент кладем как изначально максимальный
        "movb $0, %%dl\n\t"             // пока что нулевой элемент максимален
    "maximum:\n\t"
        "addq $1, %%r8\n\t"             // двигаемся к след. элементу по 1 байту, потому что char однобайтный
        "addb $1, %%dl\n\t"             // прибавляем позицию элемента
        "cmpb %%bl, (%%r8)\n\t"         // сравниваем элемент с максимальным
        "jna lower\n\t"                 // переход на lower, если правое меньше или равно
        "movb (%%r8), %%bl\n\t"         // если больше, то сохраняем новое значение максимального
        "movb %%dl, (%%rdi)\n\t"        // и сохраняем его позицию
    "lower:\n\t"
        "loop maximum\n\t"              // возвращаемся в начало цикла, пока не обнулится счетчик, иначе дальше
        "movb %%bl, (%%rsi)\n\t"        // регистр esi используется как указатель на начало адреса данных
    :
    :"arr"(array), "S"(max), "D"(max_p) // входные данные
    :"cc", "memory"                     // показывает, что память и флаги изменены
    );
}

int main()
{
    char array[] = {1, 6, 2, 3, 9, 5, 6, 7, 8};
    char *max, *max_p;
    max = (char *)malloc(1);            // выделяет 1 байт под максимальный элемент
    max_p = (char *)malloc(1);          // выделяет 1 байт под его номер
    min_max(array, max, max_p);
    printf("%d, %d\n", (int)*max, (int)*max_p);
    
    return 0;
}

// l - long, q - 8 bytes, b - 1 byte, dl - место в массиве, bl - значение максимального
// в скобках значение, без скобок адрес